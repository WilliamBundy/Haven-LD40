const char* gl21Frag = "" "#version 120\n"
"varying vec4 fcolor;\n"
"varying vec2 fuv;\n"
"varying float fflags;\n"
"uniform sampler2D image;\n"
"uniform vec2 invTextureSize;\n"
"void main()\n"
"{\n"
"	vec2 uvFinal = floor(fuv) + 0.5;\n"
"	uvFinal *= invTextureSize;\n"
"	gl_FragColor = texture2D(image, uvFinal) * fcolor;\n"
"	if(fflags > 0.5) gl_FragColor = fcolor;\n"
"}\n"
;
const char* gl21Vert = "" "#version 120\n"
"attribute vec2 xy;\n"
"attribute vec4 color;\n"
"attribute vec2 uv;\n"
"attribute float flags;\n"
"varying out vec4 fcolor;\n"
"varying out vec2 fuv;\n"
"varying out float fflags;\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(xy, 0, 1);\n"
"	fcolor = vec4(1, 1, 1, 1);\n"
"	fuv = uv;\n"
"	fflags = flags;"
"}\n"
;

const char* gl31Frag = "" "#version 140\n"
"in vec4 fcolor;\n"
"in vec2 fuv;\n"
"in float fFlags;\n"
"out vec4 gColor;\n"
"uniform sampler2D image;\n"
"uniform vec2 invTextureSize;\n"
"void main()\n"
"{\n"
"	vec2 uvFinal = floor(fuv) + 0.5;\n"
"	uvFinal *= invTextureSize;\n"
"	gColor = texture(image, uvFinal) * fcolor;\n"
"	if(fFlags > 0.5) gColor = fcolor;\n"
"}\n"
;
const char* gl31Vert = "" "#version 140\n"
"in vec2 xy;\n"
"in vec4 color;\n"
"in vec2 uv;\n"
"in float vFlags\n"
"out vec4 fcolor;\n"
"out vec2 fuv;\n"
"out float fFlags;\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(xy, 0, 1);\n"
"	fcolor = vec4(1, 1, 1, 1);\n"
"	fuv = uv;\n"
"	fFlags = vFlags;\n"
"}\n"
;

const char* gl33Frag = "" "#version 330\n"
"in vec2 fPos;\n"
"in vec2 fPixelOffset;\n"
"in vec2 fTexture; \n"
"in vec2 fTextureScale; \n"
"in vec4 fColor;\n"
"flat in int fFlags;\n"
"out vec4 gColor; \n"
"uniform sampler2D uTexture; \n"
"uniform vec4 uTint; \n"
"uniform vec4 uShadow;\n"
"uniform vec2 uInvTextureSize;\n"
"uniform float uScale;\n"
"vec2 subpixelAA(vec2 pixel, float zoom)\n"
"{\n"
"	vec2 uv = floor(pixel) + 0.5;\n"
"    uv += 1.0 - clamp((1.0 - fract(pixel)) * fTextureScale * zoom, 0.0, 1.0);\n"
"	return uv; \n"
"}\n"
"void main() \n"
"{\n"
"	//NoTexture\n"
"	vec4 baseColor = fColor;\n"
"	if(!((fFlags & 0x20) > 0)) {\n"
"		vec2 uv;\n"
"		if((fFlags & (1<<13)) > 0) {\n"
"			uv = floor(fTexture) + 0.5;\n"
"		} else {\n"
"			uv = subpixelAA(fTexture, uScale);\n"
"		}\n"
"		baseColor = texture(uTexture, uv * uInvTextureSize) * fColor;\n"
"	}\n"
"	vec3 mixedColor = mix(baseColor.rgb, uTint.rgb * baseColor.a, uTint.a);\n"
"	gColor.rgb = mixedColor;\n"
"	gColor.a = baseColor.a;\n"
"	gColor *= baseColor.a;\n"
"	//IsCircle\n"
"	if((fFlags & 0x400) > 0) {\n"
"		vec2 dl = fPos - vec2(0.5, 0.5);\n"
"		//dist^2 = mag^2 - (0.5)^2\n"
"		float dist2 = dot(dl, dl) - 0.25;\n"
"		if(dist2 > 0) {\n"
"			gColor = vec4(0, 0, 0, 0);\n"
"		}\n"
"	}\n"
"}\n"
;
const char* gl33Vert = "" "#version 330\n"
"layout(location=0) in int vFlags; \n"
"layout(location=1) in vec4 vColor;\n"
"layout(location=2) in vec2 vPos; \n"
"layout(location=3) in vec2 vSize; \n"
"layout(location=4) in vec2 vCenter; \n"
"layout(location=5) in vec4 vTexture; \n"
"layout(location=6) in float vAngle;\n"
"out vec2 fPos;\n"
"out vec2 fPixelOffset;\n"
"out vec2 fTexture; \n"
"out vec2 fTextureScale; \n"
"out vec4 fColor;\n"
"flat out int fFlags;\n"
"uniform mat4 uOrtho; \n"
"uniform vec2 uOffset;\n"
"uniform vec2 uViewport;\n"
"uniform float uScale;\n"
"float[4] corners = float[4](-0.5, -0.5, 0.5, 0.5); \n"
"float[9] offsetX = float[9](0.0, 0.5, 0.0, -0.5, -0.5, -0.5,  0.0,  0.5, 0.5); \n" 
"float[9] offsetY = float[9](0.0, 0.5, 0.5,  0.5,  0.0, -0.5, -0.5, -0.5, 0.0); \n"
"void main() \n"
"{ \n"
"	if((vFlags & 0x10) > 0) {\n"
"		gl_Position = vec4(0, 0, 0, 0); \n"
"		fTexture = vec2(0, 0); \n"
"		fColor = vec4(0, 0, 0, 0);\n"
"		fFlags = 0x20;\n"
"		return; \n"
"	} \n"
"	\n"
"	fColor = vColor.wzyx;\n"
"	fFlags = vFlags;\n"
"	int vx = gl_VertexID & 2; \n"
"	int vy = ((gl_VertexID & 1) << 1) ^ 3; \n"
"	int anchor = vFlags & 0xF;\n"
"	vec2 size = vSize; \n"
"	vec2 pos = vec2(corners[vx], corners[vy]);\n"
"	fPos = pos + vec2(0.5, 0.5);\n"
"	pos += vec2(offsetX[anchor], offsetY[anchor]);\n"
"	\n"
"	if((vFlags & (1<<6)) > 1) {\n"
"		pos = vec2(-pos.y, pos.x); \n"
"		size.xy = size.yx;\n"
"	} \n"
"	if((vFlags & (1<<7)) > 1) {\n"
"		pos = vec2(pos.y, -pos.x); \n"
"		size.xy = size.yx;\n"
"	} \n"
"	pos *= size; \n"
"	vec2 rot = vec2(cos(vAngle), sin(vAngle));\n"
"	mat2 rotmat = mat2(\n"
"			rot.x, rot.y,\n"
"			-rot.y, rot.x);\n"
"	pos -= vCenter;\n"
"	pos = rotmat * pos;\n"
"	pos += vCenter;\n"
"	pos += vPos;\n"
"	pos -= uOffset;\n"
"	pos *= uScale; \n"
"#if 0\n"
"	//This isn't needed in the current form of AA I'm using.\n"
"	//NoAA\n"
"	if(!((vFlags & 0x2000) > 0) && !((vFlags & 0x4000) > 0)) {\n"
"		fPixelOffset = 1.0 - fract(pos);\n"
"		pos = floor(pos);\n"
"	}\n"
"#endif\n"
"	vec2 normalPos = pos * vec2(2, -2) / uViewport - vec2(1, -1);\n"
"	gl_Position = vec4(normalPos, 0, 1);\n"
"	vec4 texVec = vec4(vTexture.xy, vTexture.xy + vTexture.zw); \n"
"	if((vFlags & (1<<8)) > 1) {\n"
"		texVec.xyzw = texVec.zyxw; \n"
"	} \n"
"	if((vFlags & (1<<9)) > 1) {\n"
"		texVec.xyzw = texVec.xwzy; \n"
"	} \n"
"	float[4] texCoords = float[4](\n"
"			texVec.x, texVec.y,\n"
"			texVec.z, texVec.w); \n"
"	fTextureScale = size / (texVec.zw - texVec.xy);\n"
"	fTexture = vec2(texCoords[vx], texCoords[vy]); \n"
"} \n"
;
